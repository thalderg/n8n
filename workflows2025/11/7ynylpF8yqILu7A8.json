{
  "": "",
  "active": false,
  "connections": {
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Add Score",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Score": {
      "main": [
        [
          {
            "node": "Add Rates & Indicators",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-11-20T10:54:56.246Z",
  "id": "7ynylpF8yqILu7A8",
  "isArchived": false,
  "meta": null,
  "name": "Enrich Tweets Data",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1584,
        -400
      ],
      "id": "749a2d7f-0409-4b8c-973a-687031a59b3f",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "jsCode": "// Engagement Score Calculator with Freshness Factor (0-100 scale)\nconst tweets = $input.all();\nconst scoredTweets = [];\n\n// Get all tweets for normalization\nconst allTweets = tweets.map(item => item.json);\nconst viewCounts = allTweets.map(t => parseInt(t.view_count) || 1);\nconst followerCounts = allTweets.map(t => parseInt(t.author_followers) || 1);\n\nconst maxViews = Math.max(...viewCounts);\nconst maxFollowers = Math.max(...followerCounts);\n\nfor (const item of tweets) {\n    const tweet = item.json;\n    \n    // Parse numeric values\n    const likes = parseInt(tweet.like_count) || 0;\n    const retweets = parseInt(tweet.retweet_count) || 0;\n    const bookmarks = parseInt(tweet.bookmark_count) || 0;\n    const views = parseInt(tweet.view_count) || 1;\n    const quotes = parseInt(tweet.quote_count) || 0;\n    const followers = parseInt(tweet.author_followers) || 1;\n    \n    // FRESHNESS CALCULATION\n    const now = new Date();\n    const tweetDate = new Date(tweet.created_at);\n    const hoursOld = (now - tweetDate) / (1000 * 60 * 60);\n    const daysOld = hoursOld / 24;\n    \n    // Freshness multiplier (decays over time)\n    // for now set to 1 as we want the agent to decide\n    let freshnessMultiplier = 1.0;\n    \n    if (daysOld <= 1) {\n        freshnessMultiplier = 1.5;      // 50% boost for content < 1 day\n    } else if (daysOld <= 1.5) {\n        freshnessMultiplier = 1.3;      // 30% boost for content < 1.5 days\n    } else if (daysOld <= 2) {\n        freshnessMultiplier = 1.1;      // 10% boost for content < 2 days\n    } else if (daysOld <= 2.5) {\n        freshnessMultiplier = 0.9;      // 10% penalty for content < 2.5 days\n    } else if (daysOld <= 3) {\n        freshnessMultiplier = 0.8;      // 20% penalty for content < 3 days\n    } else {\n        freshnessMultiplier = 0.5;      // 50% penalty for content > 3 days\n    }\n    \n    // Core engagement calculation\n    const totalEngagements = likes + retweets + bookmarks + quotes;\n    const engagementRate = (totalEngagements / views) * 100;\n    \n    // Base scoring (before freshness)\n    const engagementScore = Math.min(engagementRate * 10, 40);\n    \n    const bookmarkRate = (bookmarks / views) * 100;\n    const bookmarkScore = Math.min(bookmarkRate * 12.5, 25);\n    \n    const amplificationRate = ((retweets + quotes) / views) * 100;\n    const amplificationScore = Math.min(amplificationRate * 10, 20);\n    \n    const authorityScore = (followers / maxFollowers) * 10;\n    \n    let mediaBonus = 0;\n    if (tweet.has_media === \"true\") {\n        mediaBonus = tweet.media_type === \"video\" ? 5 : 3;\n    }\n    \n    // Viral bonuses\n    let viralBonus = 0;\n    if (likes > 1000) viralBonus = 10;\n    if (likes > 5000) viralBonus = 20;\n    if (likes > 10000) viralBonus = 30;\n    \n    // Base score (before freshness)\n    const baseScore = engagementScore + bookmarkScore + amplificationScore + authorityScore + mediaBonus + viralBonus;\n    \n    // Apply freshness multiplier\n    const finalScore = Math.min(Math.round(baseScore * freshnessMultiplier), 100);\n    \n    scoredTweets.push({\n        json: {\n            ...tweet,\n            engagement_score: finalScore,\n            days_old: Math.round(daysOld * 10) / 10,  // Round to 1 decimal\n            freshness_multiplier: Math.round(freshnessMultiplier * 100) / 100,  // Round to 2 decimals\n            base_score: Math.round(baseScore)  // Score before freshness\n        }\n    });\n}\n\n// Sort by engagement score (highest first)\nscoredTweets.sort((a, b) => b.json.engagement_score - a.json.engagement_score);\n\nreturn scoredTweets;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1312,
        -400
      ],
      "id": "d512033c-c4b8-46f8-9b64-d7355b00d3c8",
      "name": "Add Score"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Analytics Code Node with Dynamic Benchmarks\nconst tweets = $input.all();\nconst enhancedTweets = [];\n\n// First pass: Calculate all metrics\nfor (const item of tweets) {\n    const tweet = item.json;\n    \n    // Parse numbers safely\n    const likes = parseInt(tweet.like_count) || 0;\n    const retweets = parseInt(tweet.retweet_count) || 0;\n    const bookmarks = parseInt(tweet.bookmark_count) || 0;\n    const quotes = parseInt(tweet.quote_count) || 0;\n    const views = parseInt(tweet.view_count) || 1;\n    \n    // Calculate engagement metrics\n    const totalEngagements = likes + retweets + bookmarks + quotes;\n    const engagementRate = parseFloat(((totalEngagements / views) * 100).toFixed(2));\n    const bookmarkRate = parseFloat(((bookmarks / views) * 100).toFixed(2));\n    const amplificationRate = parseFloat((((retweets + quotes) / views) * 100).toFixed(2));\n    \n    // Thread detection\n    const text = tweet.tweet_text;\nconst threadIndicator = \n    text.includes(\"ðŸ§µ\") ||\n    text.match(/^(\\d{1,2})\\/(\\d{1,2})\\b/) ||  // Thread numbering at start like \"1/5\"\n    text.match(/\\((\\d{1,2})\\/(\\d{1,2})\\)/) ||  // Or in parentheses \"(1/5)\"\n    text.includes(\"Thread:\") ||\n    text.includes(\"THREAD\") ||\n    text.match(/:\\s*$/) ||\n    text.match(/below\\s*[:.]*\\s*$/i) ||\n    text.includes(\"a thread\") ||\n    text.includes(\"thread ðŸ‘‡\") ||\n    text.includes(\"ðŸ‘‡\") ||\n    text.includes(\"â¬‡ï¸\") ||\n    text.match(/continued\\s*$/i) ||\n    text.match(/continue\\s*$/i) ||\n    text.match(/^\\d+\\.\\s/) ||  // ONLY if starts with \"1. \"\n    text.match(/^\\d+[\\)\\.]/) ||  // ONLY if starts with \"1)\" or \"1.\"\n    text.match(/:\\s*https?:\\/\\/t\\.co\\/\\w+\\s*$/i) ||\n    text.includes(\"let's dive in\") ||\n    text.includes(\"here's how\") ||\n    text.includes(\"step by step\") ||\n    text.includes(\"breakdown\")\n    ? \"thread\" : \"single\";\n\n    // Content type analysis\n    let contentType = \"educational\";\n    if (text.includes(\"comment\") || text.includes(\"follow\")) {\n        contentType = \"engagement_bait\";\n    } else if (text.includes(\"$\") || text.includes(\"money\")) {\n        contentType = \"monetization\";\n    } else if (text.includes(\"here's\") || text.includes(\"setup\")) {\n        contentType = \"tutorial\";\n    }\n    \n    // Call to action detection\n    const hasCallToAction = /comment|follow|repost|dm|share|like this/i.test(text);\n    \n    // Viral status based on engagement score\n    let viralStatus = \"low\";\n    if (tweet.engagement_score >= 80) viralStatus = \"viral\";\n    else if (tweet.engagement_score >= 60) viralStatus = \"high\";\n    else if (tweet.engagement_score >= 40) viralStatus = \"medium\";\n    \n    enhancedTweets.push({\n        json: {\n            ...tweet,\n            engagement_rate: engagementRate,\n            bookmark_rate: bookmarkRate,\n            amplification_rate: amplificationRate,\n            thread_indicator: threadIndicator,\n            content_type: contentType,\n            call_to_action: hasCallToAction,\n            viral_status: viralStatus\n        }\n    });\n}\n\n// Second pass: Calculate benchmarks from all tweets\nconst allTweets = enhancedTweets.map(item => item.json);\nconst engagementRates = allTweets.map(t => t.engagement_rate).sort((a, b) => a - b);\nconst bookmarkRates = allTweets.map(t => t.bookmark_rate).sort((a, b) => a - b);\nconst amplificationRates = allTweets.map(t => t.amplification_rate).sort((a, b) => a - b);\n\n// Calculate percentiles\nfunction getPercentile(arr, percentile) {\n    const index = Math.ceil((percentile / 100) * arr.length) - 1;\n    return arr[Math.max(0, index)];\n}\n\n// Create dynamic benchmarks\nconst benchmarks = {\n    engagement_rate: {\n        poor: getPercentile(engagementRates, 25),      // Bottom 25%\n        average: getPercentile(engagementRates, 50),    // Median\n        good: getPercentile(engagementRates, 75),       // Top 25%\n        excellent: getPercentile(engagementRates, 90)   // Top 10%\n    },\n    bookmark_rate: {\n        poor: getPercentile(bookmarkRates, 25),\n        average: getPercentile(bookmarkRates, 50),\n        good: getPercentile(bookmarkRates, 75),\n        excellent: getPercentile(bookmarkRates, 90)\n    },\n    amplification_rate: {\n        poor: getPercentile(amplificationRates, 25),\n        average: getPercentile(amplificationRates, 50),\n        good: getPercentile(amplificationRates, 75),\n        excellent: getPercentile(amplificationRates, 90)\n    }\n};\n\n// BENCHMARKS FOR REFERENCE:\n// These are calculated dynamically from your dataset\n// Example output might look like:\n// engagement_rate: { poor: 1.2, average: 2.8, good: 4.5, excellent: 6.2 }\n// bookmark_rate: { poor: 0.3, average: 1.1, good: 2.4, excellent: 3.8 }\n// amplification_rate: { poor: 0.1, average: 0.2, good: 0.4, excellent: 0.8 }\n\n// Third pass: Add performance classifications\nconst finalTweets = enhancedTweets.map(item => {\n    const tweet = item.json;\n    \n    // Classify engagement rate\n    let engagementClass = 'poor';\n    if (tweet.engagement_rate >= benchmarks.engagement_rate.excellent) engagementClass = 'excellent';\n    else if (tweet.engagement_rate >= benchmarks.engagement_rate.good) engagementClass = 'good';\n    else if (tweet.engagement_rate >= benchmarks.engagement_rate.average) engagementClass = 'average';\n    \n    // Classify bookmark rate\n    let bookmarkClass = 'poor';\n    if (tweet.bookmark_rate >= benchmarks.bookmark_rate.excellent) bookmarkClass = 'excellent';\n    else if (tweet.bookmark_rate >= benchmarks.bookmark_rate.good) bookmarkClass = 'good';\n    else if (tweet.bookmark_rate >= benchmarks.bookmark_rate.average) bookmarkClass = 'average';\n    \n    // Classify amplification rate\n    let amplificationClass = 'poor';\n    if (tweet.amplification_rate >= benchmarks.amplification_rate.excellent) amplificationClass = 'excellent';\n    else if (tweet.amplification_rate >= benchmarks.amplification_rate.good) amplificationClass = 'good';\n    else if (tweet.amplification_rate >= benchmarks.amplification_rate.average) amplificationClass = 'average';\n    \n    // Overall performance score (for agent decision making)\n    let overallPerformance = 'poor';\n    const classScores = {\n        'poor': 1,\n        'average': 2,\n        'good': 3,\n        'excellent': 4\n    };\n    \n    const avgScore = (classScores[engagementClass] + classScores[bookmarkClass] + classScores[amplificationClass]) / 3;\n    \n    if (avgScore >= 3.5) overallPerformance = 'excellent';\n    else if (avgScore >= 2.5) overallPerformance = 'good';\n    else if (avgScore >= 1.5) overallPerformance = 'average';\n    \n    return {\n        json: {\n            ...tweet,\n            engagement_class: engagementClass,\n            bookmark_class: bookmarkClass,\n            amplification_class: amplificationClass,\n            overall_performance: overallPerformance\n        }\n    };\n});\n\nreturn finalTweets;\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1072,
        -400
      ],
      "id": "a7b3b0c7-1a0a-4b27-936c-cbb1f24220e7",
      "name": "Add Rates & Indicators"
    }
  ],
  "pinData": {},
  "repo_name": "n8n",
  "repo_owner": "thalderg",
  "repo_path": "workflows",
  "settings": {
    "executionOrder": "v1"
  },
  "shared": [
    {
      "createdAt": "2025-11-20T10:54:56.251Z",
      "updatedAt": "2025-11-20T10:54:56.251Z",
      "role": "workflow:owner",
      "workflowId": "7ynylpF8yqILu7A8",
      "projectId": "rwZmgF8pMPgWdXwq"
    }
  ],
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-11-20T13:01:05.000Z",
  "versionId": "c05dddf4-7d13-4e58-b60a-3302db1b0db9"
}